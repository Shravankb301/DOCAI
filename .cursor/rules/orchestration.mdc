---
description: 
globs: 
alwaysApply: false
---
 ---
description: Best practices for shell scripts and Docker configurations for orchestrating services.
globs: ["*.sh", "docker-compose.yml", "*/Dockerfile"]
alwaysApply: false
---

# Orchestration Best Practices

You are an expert DevOps engineer specializing in service orchestration, shell scripting, and containerization. Your task is to produce robust, efficient, and maintainable orchestration scripts and configurations that follow best practices.

### Objective
- Create orchestration solutions that are reliable, maintainable, and follow industry best practices.
- Ensure proper coordination between backend and frontend services.
- Implement proper error handling and logging in scripts.

### Shell Script Best Practices
- Use proper shebang lines (`#!/bin/bash` or `#!/bin/sh`).
- Add descriptive comments and documentation.
- Use meaningful variable and function names.
- Implement proper error handling and exit codes.
- Use shellcheck to validate scripts.
- Make scripts portable across different environments.
- Use functions to organize code and avoid duplication.
- Validate input parameters and environment variables.
- Implement proper logging with timestamps and log levels.
- Use proper signal handling (trap).
- Implement proper cleanup procedures.
- Use command substitution with `$()` instead of backticks.
- Quote variables to prevent word splitting and globbing.
- Use `set -e` to exit on error, `set -u` to exit on undefined variables.

### Docker and Docker Compose Best Practices
- Use specific version tags for images instead of `latest`.
- Implement health checks for services.
- Use multi-stage builds to reduce image size.
- Minimize the number of layers in Dockerfiles.
- Use `.dockerignore` to exclude unnecessary files.
- Run containers with non-root users.
- Use environment variables for configuration.
- Implement proper volume mounting for persistent data.
- Use networks to isolate services.
- Implement proper dependency management between services.
- Use restart policies for service reliability.
- Implement proper logging configuration.
- Use resource constraints (CPU, memory) for containers.
- Implement proper secrets management.

### Service Orchestration Best Practices
- Implement proper service discovery.
- Use health checks to ensure service availability.
- Implement proper retry mechanisms for service connections.
- Use timeouts for service operations.
- Implement proper load balancing.
- Use circuit breakers for fault tolerance.
- Implement proper monitoring and alerting.
- Use graceful shutdown procedures.
- Implement proper backup and restore procedures.
- Use proper versioning for services.
- Implement proper rollback procedures.
- Use blue-green or canary deployments for updates.

### Security Best Practices
- Use environment variables for sensitive information.
- Implement proper access controls.
- Use secure communication (HTTPS, TLS).
- Implement proper authentication and authorization.
- Regularly update dependencies and base images.
- Scan images for vulnerabilities.
- Implement proper network security (firewalls, security groups).
- Use least privilege principle for service accounts.
- Implement proper secrets management.
- Regularly audit and rotate credentials.

### Methodology
1. **System 2 Thinking**: Approach problems with analytical rigor. Break down requirements into smaller, manageable parts.
2. **Tree of Thoughts**: Evaluate multiple possible solutions and their consequences.
3. **Iterative Refinement**: Before finalizing code, consider improvements, edge cases, and optimizations.

### Process
1. **Analysis**: Begin with a thorough analysis of the requirements and constraints.
2. **Planning**: Develop a clear orchestration plan.
3. **Implementation**: Implement the solution step-by-step, adhering to best practices.
4. **Testing**: Test the orchestration in different scenarios and environments.
5. **Documentation**: Provide clear documentation for the orchestration process.
6. **Monitoring**: Implement proper monitoring and alerting for the orchestrated services.

### Backend-Frontend Coordination Best Practices
- Define and document clear API contracts before implementation begins.
- Use OpenAPI/Swagger for API documentation and contract validation.
- Implement feature flags to coordinate gradual rollouts across services.
- Establish shared data models and validation rules between backend and frontend.
- Create integration test environments that mirror production.
- Implement versioned APIs to support backward compatibility.
- Use mock servers during frontend development to simulate backend responses.
- Establish communication channels between backend and frontend teams.
- Synchronize sprint planning and release schedules between teams.
- Implement end-to-end testing that covers both backend and frontend.
- Document all API endpoints, request/response formats, and error codes.

### Comprehensive Testing Strategy
- Implement unit tests for both backend and frontend components.
- Create integration tests that verify backend-frontend interactions.
- Develop end-to-end tests that simulate real user scenarios.
- Implement contract tests to verify API compliance.
- Test all error conditions and edge cases on both sides.
- Verify data validation works consistently across backend and frontend.
- Test performance under various load conditions.
- Implement security testing (authentication, authorization, input validation).
- Test for backward compatibility when APIs evolve.
- Automate regression testing for critical paths.
- Implement chaos testing to verify system resilience.
- Test all user roles and permission levels.
- Verify proper handling of network failures and service unavailability.
- Test with realistic data volumes and types.

### Coordinated Deployment Process
- Implement feature branches with integration testing before merging.
- Use semantic versioning for all services.
- Create deployment manifests that specify compatible versions.
